{
	
	Proyecto1.gcl
	DESCRIPCIÓN: Este es el algoritmo que sigue el juego Cuatro en línea, que consiste
	en una matriz 6x7 y dos "fichas" (para 2 jugadores) que tendrán el valor 1 y 2 
	cuando ocupen una posición de la matriz, y el objetivo del juego es completar una línea 
	de 4 fichas de forma vertical, horizontal o diagonal.

	Autores:
	       Br. Pietro Iaia
	       Br. Antonella Requena
	Última fecha de modificación: 03/03/2018

}

proc inicializarPartida(in N,M: int;out nombreJugador:string,Matrix: array[0..N)[0..M) of int)
     var i,j:int;
     {N>0 /\ M>0}
     {(%forall i,j: 0<=i<N /\ 0<=j<M : Matrix[i][j]=0)}
    [
     write("Ingrese su nombre: ") ;
     read(nombreJugador) ;
     i:=0;
     do i<N ->
       j:=0;
       do j<M ->
         Matrix[i][j]:=0
         ;j:=j+1 
       od
       ;i:=i+1
     od
   ]

proc ObtenerJugada(in n:int,t:int,nombreJugador:string;in-out Matrix: array[0..N)[0..M) )
     var i,j:int;
     {(t=1 \/ t=2) /\ (n=1 \/ n=2)}
     {(t=1 /\ Matrix[i][j]=1) \/ (t=2 /\ (%any i,j : 0<=i<N /\ 0<=j<M : Matrix[i][j]=2) )} //Esta postcondicion no garantiza que la casilla del CPU se haya asignado bien OJO
     if t=1 ->
        write("Su turno") ;
        write("Por favor, "+nombreJugador+" introduzca una jugada: ") ;
        read(j) ;
        validarJugada(Matrix[i][j])
        if esValida=True ->
          Matrix[i][j]:=1 ; //i debe tener el valor de la fila de arriba a la ultima que fue ocupada
        [] esValida=False ->
           write("La jugada no es valida. Intentelo de nuevo")
           //No se sabe si hay que hacerlo de forma robusta o abortar el programa
        fi

     [] t!=1 -> //decimos t!=1 para efectos practicos de la completitud de las guardias, pues ya habremos chequeado que si t!=1 entonces t=2
        write("Turno del computador") ;
        if n=1 ->
           //algoritmo random para colocar la ficha en cualquier sitio que este vacio
           i:=0;
           do i<N -> //Aca no lo hace de forma aleatoria pues va a ocuoar la primera casilla que vea vacia (ACOMODAR)
             j:=0;
             do j<M ->
               validarJugada(Matrix[i][j]);
               if esValida=True ->
                  Matrix[i][j]:=2
               [] esValida=False ->
                  skip
               fi
        [] n!=1 -> //decimos n!=1 para efectos practicos de la completitud de las guardias, pues ya habremos chequeado que si n!=1 entonces n=2
           //algoritmo para colocar la ficha de acuerdo a la jugada anterior (Nivel medio)
        fi
     fi
func validarJugada(Matrix: array[0..N)[0..M) ) -> bool
     {Matrix[i][j]=1 \/ Matrix[i][j]=2 \/ Matrix[i][j]=0}
     {esValida=Matrix[i][j]=0 \/ esValida=Matrix[i][j]=1 \/ esValida=Matrix[i][j]=2} //Pre y post no son las mas adecuadas
     [
		var esValida:=bool;
		if Matrix[i][j]=0 ->
		   esValida:=True
		[] Matrix[i][j]!=0 ->
		    esValida:=False
		//Meter ifs para verificar casilla extrema inferior y casilla vacia encima de otra ocupada por otra ficha

		>> esValida
     ]
func otraPartida(sigue:bool) -> bool
      {Precondicion}
      {Postcondicion}
	  [
	    var jugarOtra : bool;
		var y : string;
		write("¿Desea jugar otra partida? Tipee Si o No ")
		read(y)
	    if y="Si" ->
	       jugarOtra:=True
	    [] y="No" ->
	       jugarOtra:=False
	    fi

	    >>jugarOtra
	]
proc ReflejarJugada(in-out Matrix[0..N][0..M])
{Precondicion}
{Postcondicion}
  [
   // reflejar jugada write(Matrix[i][j]) 

  ]
func CambiarTurno(t:int) -> int
 {}
 {}
 [ 
  var turno: int;
  if t=1 ->
     turno:=2
  [] t!=1 ->
     turno:=1
  fi
  >>turno
 ]

[   

    CONST    N=6,M=7;     
    VAR      nombreJugador: string; 
             jugada: array[0..N)[0..M) of int;
             turno:int;
             nivel:int;
   {true}
   jugarOtra=True;
   do jugarOtra=True -> 
           inicializarPartida(N,M); 
      do jugarOtra=True /\ siguePartida=True ->         
           ObtenerJugada(nivel, turno, nombreJugador, jugada[i][j]);          
           if esValida=True ->            
               ReflejarJugada(jugada[i][j]);            
               CambiarTurno(turno)         
           [] esValida=False ->           
                // Error   
           fi 
       od; 
       //Desplegar ganador de la partida; Finalizar partida: No implementado aun
    od; 
    //Desplegar resultados de conjunto de partidas: No implementado aun 
]