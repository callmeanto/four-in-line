{
	
	Proyecto1.gcl
	DESCRIPCIÓN: Este es el algoritmo que sigue el juego Cuatro en línea, que consiste
	en una matriz 6x7 y dos "fichas" (para 2 jugadores) que tendrán el valor 1 y 2 
	cuando ocupen una posición de la matriz, y el objetivo del juego es completar una línea 
	de 4 fichas de forma vertical, horizontal o diagonal.

	Autores:
	       Br. Pietro Iaia
	       Br. Antonella Requena
	Última fecha de modificación: 05/03/2018

}


proc SeguirJugando (in-out siguePartida:bool)
  {siguePartida=True}
  {siguePartida=True \/ siguePartida=False} //PostCondicion Basico, puede cambiarse si se encuentra uno mejor
  [ 
    var seguirJugando: string
    write ("Quiere seguir jugando?")
    read (seguirJugando)
    if seguirJugando="Si" ->
        skip
    [] seguirJugando="No" ->
        siguePartida:=False //Lo que me di cuenta aqui es que aunque ponga que es False, jugara una partida mas y luego se saldra, no se si deberia poner un break (No recuerdo si GCL lo tiene)
  ]

proc DeterminarGanador (in N:int, M:int, turno:int, Matrix:int, out Ganador:int)
{turno=1 \/ turno=2}
{Ganador=0 \/ Ganador=1 \/ Ganador=2}
[
    Ganador:=0

    LineaVertical (N, M, turno, Matrix, Ganador)
    LineaHorizontal (N, M, turno, Matrix, Ganador)
    LineaDiagonalIzquierda (turno, Matrix, Ganador)
    LineaDiagonalDerecha (turno, Matrix, Ganador)
    
]

proc DeterminarPartidaTerminada (in N:int, M:int, Ganador:int, Matrix:int, in-out siguePartida:bool)
{Ganador=0 \/ Ganador=1 \/ Ganador=2}
{siguePartida= True \/ siguePartida= False}
[ var n,i,j:int 
    n:=0
    i:=0
    do i<N ->
        j:=0
        do j<M ->
            if Matrix[i][j]=0 ->
                n:=1
            [] Matrix[i][j]!=0 ->
                skip
            fi;
            j:=j+1
        od;
        i:=i+1
    od;
    if n=1 ->
        skip
    [] n!=1 ->
        siguePartida:=False
    fi;

    if Ganador=0 ->
        skip
    [] Ganador=1 \/ Ganador=2 ->
        siguePartida:=False
    fi
]

proc LineaVertical (in N:int, M:int, turno:int, Matrix:int, in-out Ganador:int)
{turno=1 \/ turno=2}
{Ganador=0 \/ Ganador=1 \/ Ganador=2}
[ var j,i:int
    i:=0;
    do i<N-3 ->
        j:=0
        do j<M ->
            if Matrix[i][j]=turno /\ Matrix[i+1][j]=turno /\ Matrix[i+2][j]=turno /\ Matrix[i+3][j]=turno ->
                Ganador:=turno
            [] Matrix[i][j]!=turno \/ Matrix[i+1][j]!=turno \/ Matrix[i+2][j]!=turno \/ Matrix[i+3][j]!=turno ->
                skip
            fi;
            j:=j+1
        od;
        i:=i+1
    od
]

proc LineaHorizontal (in N:int, M:int, turno:int, Matrix:int, in-out Ganador:int)
{turno=1 \/ turno=2}
{Ganador=0 \/ Ganador=1 \/ Ganador=2}
[ var i:int
    j:=0
    do j<M-3 ->
        i:=0
        do i<N ->
            if Matrix[i][j]=turno /\ Matrix[i][j+1]=turno /\ Matrix[i][j+2]=turno /\ Matrix[i][j+3]=turno ->
                Ganador:=turno
            [] Matrix[i][j]!=turno \/ Matrix[i][j+1]!=turno \/ Matrix[i][j+2]!=turno \/ Matrix[i][j+3]!=turno ->
                skip
            fi;
            i:=i+1
        od;
        j:=j+1
    od
]

proc LineaDiagonalDerecha (in turno:int, Matrix:int, in-out Ganador:int)
{turno=1 \/ turno=2}
{Ganador=0 \/ Ganador=1 \/ Ganador=2}
[ var i,j:int
    i:=0
    do i<3 ->
        j:=0
        do j<4 ->
            if Matrix[i][j]=turno /\ Matrix[i+1][j+1]=turno /\ Matrix[i+2][j+2]=turno /\ Matrix[i+3][j+3]=turno ->
                Ganador:=turno
            [] Matrix[i][j]!=turno and Matrix[i+1][j+1]!=turno and Matrix[i+2][j+2]!=turno and Matrix[i+3][j+3]!=turno ->
                skip
            fi;
            j:=j+1
        od;
        i:=i+1
    od
]

proc LineaDiagonalIzquierda (in turno:int, Matrix:int, in-out Ganador:int)
{turno=1 \/ turno=2}
{Ganador=0 \/ Ganador=1 \/ Ganador=2}
[ var i,j:int
    i:=0
    do i<3 ->
        j:=6
        do j>2 ->
            if Matrix[i][j]=turno /\ Matrix[i+1][j-1]=turno /\ Matrix[i+2][j-2]=turno /\ Matrix[i+3][j-3]=turno ->
                Ganador:=turno
            [] Matrix[i][j]!=turno \/ Matrix[i+1][j-1]!=turno \/ Matrix[i+2][j-2]!=turno \/ Matrix[i+3][j-3]!=turno ->
                skip
            fi;
            j=j-1
        od;
        i=i+1
    od
]

DesplegarGanador (in Ganador:int)
{Ganador=1 \/ Ganador=0 \/ Ganador=2}
{True}
[
    if Ganador=1 -> write("El ganador de la partida es " +NombreJugador+ "!")
    [] Ganador=2 -> write("El ganador de la partida es el computador!")
    [] Ganador=0 -> write("La partida termino en empate!")
    fi
]

CambiarTurno (in-out turno:int)
{turno=1 \/ turno=2}
{turno=1 \/ turno=2}
[
    if turno=1 -> turno:=2
    [] turno=2 -> turno:=1
    fi
]

ReflejarJugada ( in jugada:int)
{True}
{True}
[ var UltimaJugada: int

    Tablero(Inicio: Matrix[0][0], termina: Matrix[5][6])
    UltimaJugada:= read(jugada)
    ColocarJugada(UltimaJugada, jugada, Tablero) // ColocarJugada(que cosa, en que lugar, donde se pondra)
]

[   

    CONST    N=6,M=7;     
    VAR      nombreJugador: string; 
             jugada: array[0..N)[0..M) of int;
             turno:int;
             nivel:int;
             siguePartida: bool;
             jugarOtra: bool
             Ganador:int
   {true}
   jugarOtra:=True;
   do jugarOtra=True -> 
           siguePartida:= True; 
           inicializarPartida(N,M); 
      do jugarOtra=True /\ siguePartida=True ->  
           SeguirJugando(siguePartida);
           ObtenerJugada(nivel, turno, nombreJugador, jugada[i][j]);          
           if esValida=True ->            
               ReflejarJugada(jugada);            
               CambiarTurno(turno)         
           [] esValida=False ->           
                // Error   
           fi;
           DeterminarGanador(N, M, turno, Matrix, Ganador);
           DeterminarPartidaTerminada(N, M, Ganador, Matrix, siguePartida)
       od; 
       DesplegarGanador(Ganador)
    od; 
    //Desplegar resultados de conjunto de partidas: No implementado aun 
]