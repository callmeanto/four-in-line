{
	
	Proyecto1.gcl
	DESCRIPCIÓN: Este es el algoritmo que sigue el juego Cuatro en línea, que consiste
	en una matriz 6x7 y dos "fichas" (para 2 jugadores) que tendrán el valor 1 y 2 
	cuando ocupen una posición de la matriz, y el objetivo del juego es completar una línea 
	de 4 fichas de forma vertical, horizontal o diagonal.

	Autores:
	       Br. Pietro Iaia
	       Br. Antonella Requena
	Última fecha de modificación: 05/03/2018

}


proc SeguirJugando (in-out siguePartida:true)
  {siguePartida=True}
  {siguePartida=True \/ siguePartida=False} //PostCondicion Basico, puede cambiarse si se encuentra uno mejor
  [ 
    var seguirJugando: string
    write ("Quiere seguir jugando?")
    read (seguirJugando)
    if seguirJugando="Si" ->
        skip
    [] seguirJugando="No" ->
        siguePartida:=False //Lo que me di cuenta aqui es que aunque ponga que es False, jugara una partida mas y luego se saldra, no se si deberia poner un break (No recuerdo si GCL lo tiene)
    >>seguirJugando
  ]

proc DeterminarGanador (in turno: int, jugada:int, out Ganador:int)
{turno=1 \/ turno=2}
{Ganador=0 \/ Ganador=1 \/ Ganador=2}
[
    Ganador:=0

    Ganador:=LineaVertical (turno, jugada,Ganador)
    Ganador:=LineaHorizontal (turno, jugada,Ganador)
    Ganador:=LineaDiagonalIzquierda (turno, jugada,Ganador)
    Ganador:=LineaDiagonalDerecha (turno, jugada,Ganador)
    
    >>Ganador

]

proc DeterminarPartidaTerminada (in Ganador:int, jugada:int, in-out siguePartida:bool)
{Ganador=0 \/ Ganador=1 \/ Ganador=2}
{siguePartida= True \/ siguePartida= False}
[ var n:int, i:int, j:int
    n:=0
    i:=0
    do i<6 ->
        j:=0
        do j<7 ->
            if jugada[i][j]=0 ->
                n:=1
            [] jugada[i][j]!=0 ->
                skip
            fi;
            j:=j+1
        od;
        i:=i+1
    od;
    if n=1 ->
        pass
    [] n!=1 ->
        siguePartida:=False
    fi;

    if Ganador=0 ->
        skip
    [] Ganador=1 ->
        siguePartida:=False
    [] Ganador=2 ->
        siguePartida:=False
    fi
    >> siguePartida
]

proc LineaVertical (in turno:int, jugada:int, in-out Ganador:int) //Se verifica cada casilla, puede mejorarse
{turno=1 \/ turno=2}
{Ganador=0 \/ Ganador=1 \/ Ganador=2}
[ var j:int
    j:=0
    do j<7 ->
        if jugada[0][j]=turno /\ jugada[1][j]=turno /\ jugada[2][j]=turno /\ jugada[3][j]=turno -> Ganador:=turno
        [] jugada[1][j]=turno /\ jugada[2][j]=turno /\ jugada[3][j]=turno /\ jugada[4][j]=turno -> Ganador:=turno
        [] jugada[2][j]=turno /\ jugada[3][j]=turno /\ jugada[4][j]=turno /\ jugada[5][j]=turno -> Ganador:=turno
        [] else -> skip 
        fi
        j:=j+1
    od
    >>Ganador 
]

proc LineaHorizontal (in turno:int, jugada:int, in-out Ganador:int) //Se verifica cada casilla, puede mejorarse
{turno=1 \/ turno=2}
{Ganador=0 \/ Ganador=1 \/ Ganador=2}
[ var i:int
    i:=0
    do i<6 ->
        if jugada[i][0]=turno /\ jugada[i][1]=turno /\ jugada[i][2]=turno /\ jugada[i][3]=turno -> Ganador:=turno
        [] jugada[i][1]=turno /\ jugada[i][2]=turno /\ jugada[i][3]=turno /\ jugada[i][4]=turno -> Ganador:=turno
        [] jugada[i][2]=turno /\ jugada[i][3]=turno /\ jugada[i][4]=turno /\ jugada[i][5]=turno -> Ganador:=turno
        [] jugada[i][3]=turno /\ jugada[i][4]=turno /\ jugada[i][5]=turno /\ jugada[i][6]=turno -> Ganador:=turno
        [] else -> skip
        fi;
        i:=i+1
    od
    >>Ganador 
]

proc LineaDiagonalDerecha (in turno:int, jugada:int, in-out Ganador:int) //Se verifica cada casilla, puede mejorarse
{turno=1 \/ turno=2}
{Ganador=0 \/ Ganador=1 \/ Ganador=2}
[
    if jugada[0][0]=turno /\ jugada[1][1]=turno /\ jugada[2][2]=turno /\ jugada[3][3]=turno -> Ganador:=turn0
    [] jugada[1][1]=turno /\ jugada[2][2]=turno /\ jugada[3][3]=turno /\ jugada[4][4]=turno -> Ganador:=turno
    [] jugada[2][2]=turno /\ jugada[3][3]=turno /\ jugada[4][4]=turno /\ jugada[5][5]=turno -> Ganador:=turno
    [] jugada[1][0]=turno /\ jugada[2][1]=turno /\ jugada[3][2]=turno /\ jugada[4][3]=turno -> Ganador:=turno
    [] jugada[2][1]=turno /\ jugada[3][2]=turno /\ jugada[4][3]=turno /\ jugada[5][4]=turno -> Ganador:=turno
    [] jugada[2][0]=turno /\ jugada[3][1]=turno /\ jugada[4][2]=turno /\ jugada[5][3]=turno -> Ganador:=turno
    [] jugada[0][1]=turno /\ jugada[1][2]=turno /\ jugada[2][3]=turno /\ jugada[3][4]=turno -> Ganador:=turno
    [] jugada[1][2]=turno /\ jugada[2][3]=turno /\ jugada[3][4]=turno /\ jugada[4][5]=turno -> Ganador:=turno
    [] jugada[2][3]=turno /\ jugada[3][4]=turno /\ jugada[4][5]=turno /\ jugada[5][6]=turno -> Ganador:=turno
    [] jugada[0][2]=turno /\ jugada[1][3]=turno /\ jugada[2][4]=turno /\ jugada[3][5]=turno -> Ganador:=turno
    [] jugada[1][3]=turno /\ jugada[2][4]=turno /\ jugada[3][5]=turno /\ jugada[4][6]=turno -> Ganador:=turno
    [] jugada[0][3]=turno /\ jugada[1][4]=turno /\ jugada[2][5]=turno /\ jugada[3][6]=turno -> Ganador:=turno
    [] else -> skip
    fi;
    >>Ganador 
]

proc LineaDiagonalIzquierda (in turno:int, jugada:int, in-out Ganador:int) //Se verifica cada casilla, puede mejorarse
{turno=1 \/ turno=2}
{Ganador=0 \/ Ganador=1 \/ Ganador=2}
[
    if jugada[0][6]=turno /\ jugada[1][5]=turno /\ jugada[2][4]=turno /\ jugada[3][3]=turno -> Ganador:=turno
    [] jugada[1][5]=turno /\ jugada[2][4]=turno /\ jugada[3][3]=turno /\ jugada[4][2]=turno -> Ganador:=turno
    [] jugada[2][4]=turno /\ jugada[3][3]=turno /\ jugada[4][2]=turno /\ jugada[5][1]=turno -> Ganador:=turno
    [] jugada[1][6]=turno /\ jugada[2][5]=turno /\ jugada[3][4]=turno /\ jugada[4][3]=turno -> Ganador:=turno
    [] jugada[2][5]=turno /\ jugada[3][4]=turno /\ jugada[4][3]=turno /\ jugada[5][2]=turno -> Ganador:=turno
    [] jugada[2][6]=turno /\ jugada[3][5]=turno /\ jugada[4][4]=turno /\ jugada[5][3]=turno -> Ganador:=turno
    [] jugada[0][5]=turno /\ jugada[1][4]=turno /\ jugada[2][3]=turno /\ jugada[3][2]=turno -> Ganador:=turno
    [] jugada[1][4]=turno /\ jugada[2][3]=turno /\ jugada[3][2]=turno /\ jugada[4][1]=turno -> Ganador:=turno
    [] jugada[2][3]=turno /\ jugada[3][2]=turno /\ jugada[4][1]=turno /\ jugada[5][0]=turno -> Ganador:=turno
    [] jugada[0][4]=turno /\ jugada[1][3]=turno /\ jugada[2][2]=turno /\ jugada[3][1]=turno -> Ganador:=turno
    [] jugada[1][3]=turno /\ jugada[2][2]=turno /\ jugada[3][1]=turno /\ jugada[4][0]=turno -> Ganador:=turno
    [] jugada[0][3]=turno /\ jugada[1][2]=turno /\ jugada[2][1]=turno /\ jugada[3][0]=turno -> Ganador:=turno
    [] else -> skip
    fi;
    >>Ganador 
]

DesplegarGanador (in Ganador:int)
{Ganador=1 \/ Ganador=0 \/ Ganador=2}
{True}
[
    if Ganador=1 -> write("El ganador de la partida es " +NombreJugador+ "!")
    [] Ganador=2 -> write("El ganador de la partida es el computador!")
    [] Ganador=0 -> write("La partida termino en empate!")
    fi
]

CambiarTurno (in turno:int, out t:int)
{turno=1 \/ turno=2}
{t=1 \/ t=2}
[ var t:int
    if turno=1 -> t:=2
    [] turno=2 -> t:=1
    fi
    >>t
]

[   

    CONST    N=6,M=7;     
    VAR      nombreJugador: string; 
             jugada: array[0..N)[0..M) of int;
             turno:int;
             nivel:int;
             siguePartida: bool;
             jugarOtra: bool
             Ganador:int
   {true}
   jugarOtra:=True;
   do jugarOtra=True -> 
           siguePartida:= True; 
           inicializarPartida(N,M); 
      do jugarOtra=True /\ siguePartida=True ->  
           siguePartida:=SeguirJugando(siguePartida)
           ObtenerJugada(nivel, turno, nombreJugador, jugada[i][j]);          
           if esValida=True ->            
               ReflejarJugada(jugada);            
               turno:=CambiarTurno(turno)         
           [] esValida=False ->           
                // Error   
           fi;
           Ganador:=DeterminarGanador(turno, jugada); //Siempre sera Ganador=0 hasta que vea si gano el usuario (Ganador=1) o la computadora (Ganador=2) o se queda igual si es empate
           siguePartida:=DeterminarPartidaTerminada(Ganador, jugada, siguePartida)
       od; 
       DesplegarGanador(Ganador)
    od; 
    //Desplegar resultados de conjunto de partidas: No implementado aun 
]